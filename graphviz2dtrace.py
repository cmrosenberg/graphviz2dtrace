#!/usr/local/bin/python
"""graphviz2dtrace.py

Usage:
    graphviz2dtrace.py FILE
    graphviz2dtrace.py --version
    graphviz2dtrace.py (-m | --mapping) <map> FILE
    graphviz2dtrace.py (-h | --help)

Options:
    -h --help               Show this screen.
    -v --version            Show version.
    -m --mapping            Provide JSON mapping file for atomic variables
"""

from docopt import docopt
from itertools import count
import pygraphviz as pgv
import json
import re
from datetime import datetime
from sys import exit

VERSION = "0.1"

def dtrace_preamble():

    return "#!/usr/sbin/dtrace -qs\n\n#pragma D option defaultargs"

def script_signature():

    signature = []

    signature.append("This script was automatically generated by " +
                     "graphviz2dtrace version " + VERSION)

    signature.append("on " + str(datetime.utcnow()) +
                     " UTC. To run it, make it executable with")

    signature.append("\nchmod +ux\n\n" +
                     "and then run it with root privileges. Example:")

    signature.append("\nsudo myscript.d -c program-to-be-monitored");

    return "\n/*\n" + "\n".join(signature) + "\n*/\n"

def create_node_ordering(graph, start_node):

    ordering = {}
    ordering[start_node] = 0

    counter = count(start=1)

    for node in graph.nodes():
        if node not in ordering:
            ordering[node] = counter.next()

    return ordering

def unquote(string):
    if string[0] == "\"":
        return string[1:-1]
    return string

def enforce_mapping(graph, mapping):

    if mapping:
        for edge in graph.edges():
            label = unquote(edge.attr['label'])
            start_edge = edge.attr['label'] != u"START"
            if start_edge and (label in mapping):
                    edge.attr['label'] = mapping[label]

    return graph

def load_automata(path):
    graph_file = open(path, 'ro');
    G = pgv.AGraph("".join(graph_file.readlines()))
    graph_file.close()
    return G

def load_mapping(path):
    mapping_fptr = open(path, 'ro')
    mapping = json.load(mapping_fptr)
    mapping_fptr.close()
    return mapping

def find_start_node(edges):
    for edge in edges:
        if edge[0] == u"start":
            return edge[1]

def remove_question_edges(graph):

    q_edges = filter(lambda edge : edge.attr['label'] == u"?",
                     graph.edges())

    for edge in q_edges:
        assert edge[0] == edge[1], "wildcard transitions between states not supported"
        graph.delete_edge(edge[0], edge[1])

    return graph

def create_probe_ordering(graph):
        probe_ordering = {}
        counter = count()
        for probe in unique_probes(graph):
            probe_ordering[probe] = counter.next()
        return probe_ordering

def unique_probes(graph):
    return list(set(map(lambda edge: edge.attr['label'],
                        graph.edges())))

def control_variables_declaration():
    return "int HAS_VERDICT;\nint state;"

def transition_function_declaration(graph):
    n_nodes = len(graph.nodes())
    distinct_probes = len(unique_probes(graph))
    return "int tf[{0}][{1}];\n".format(n_nodes, distinct_probes)

def state_initialization_statement(probe_ordering):

    # Determine the number of macro variables used, and
    # assign a macro variable for holding an (optional)
    # start state. The assigned macro variable is the
    # next available macro variable.

    macro_vars = set()

    pattern = re.compile("\$(\d)+")

    probes_w_macro_vars = filter(lambda p: pattern.search(p) != None,
                                 probe_ordering)

    macro_vars.update(map(lambda probe: pattern.search(probe).group(),
                               probes_w_macro_vars))

    sorted_macro_vars = sorted(list(macro_vars))
    idealized_macro_vars = map(lambda n: "$"+str(n),
                               range(1, len(macro_vars)+1))

    no_gaps = sorted_macro_vars == idealized_macro_vars

    assert no_gaps, "Gaps between macro variables not permitted"

    variable = "$" + str(len(macro_vars)+1)

    return "\tstate = (" + variable + " ? " +  variable + ": 0);"

def begin_block(graph, node_ordering, probe_ordering):

    statements = []
    statements.append("dtrace:::BEGIN\n{")

    tfi = transition_function_init(graph, node_ordering,
                                             probe_ordering)
    statements.append(tfi)

    statements.append("\tHAS_VERDICT = 0;");
    statements.append(state_initialization_statement(probe_ordering))
    statements.append("}\n")

    return "\n".join(statements)

def transition_function_init(graph, node_ordering, probe_ordering):

    def encode_entry(state, symbol, resulting_state):
        components = []
        components.append("\ttf[")
        components.append(str(state))
        components.append("][")
        components.append(str(symbol))
        components.append("] = ")
        components.append(str(resulting_state))
        components.append(";")
        return "".join(components)

    statements = []

    probes = set(map(lambda edge: edge.attr['label'], graph.edges()))

    for node in graph.nodes():

        # For every outbound edge from the node, insert the destination
        # state in the transition table

        for edge in graph.out_edges([node]):
            probe = edge.attr['label']
            statements.append(encode_entry(node_ordering[node],
                                           probe_ordering[probe],
                                           node_ordering[edge[1]]))

        # Since the transition function needs to be complete, we
        # determine which probes were used as labels in the outbound
        # edges and which where not. For those probes which had no
        # corresponding outgoing edge from this node, we encode in the
        # transition table that the state should remain in the same
        # state.

        covered_probes = set(map(lambda edge: edge.attr['label'],
                                 graph.out_edges([node])))

        uncovered_probes = probes.difference(covered_probes)

        for probe in uncovered_probes:
            statements.append(encode_entry(node_ordering[node],
                                           probe_ordering[probe],
                                           node_ordering[node]))

    return "\n".join(sorted(statements))

def plain_probe(probe):
    if "/" in probe:
        return probe.split("/")[0]
    return probe

def create_predicate(ordered_nodes, probe):


    core = " ||\n".join(map(lambda node: "state == " + str(node),
                            ordered_nodes))

    #Check if probe already contains a predicate
    if "/" in probe:
        try:
            custom_predicate = probe.split("/")[1]
            return "/ (" + custom_predicate + ") && (" + core + ")/"

        except IndexError:
            print "Malformed probe " + probe + ". Exiting..."
            exit(1)

    return "/" + core + "/"

def blocks_from_map(probe_map, node_ordering, accepting):
    blocks = []

    for probe in probe_map:
        nodes = map(lambda node: node_ordering[node], probe_map[probe])

        predicate = create_predicate(nodes, probe)
        verdict = "\"ACCEPTED\"" if accepting else "\"REJECTED\""

        blocks.append(plain_probe(probe) + "\n" + predicate
                      + "\n{\n"
                      + "\ttrace(" + verdict + ");\n"
                      + "\tHAS_VERDICT = 1;\n"
                      + "\texit(0);\n"
                      + "}\n")
    return blocks

def get_probe_map(graph, states):

    probe_map = {}

    for state in states:
        for edge in graph.in_edges([state]):
            probe = edge.attr['label']
            if probe not in probe_map:
                probe_map[probe] = []

            probe_map[probe].append(edge[0])

    return probe_map

def accepting_blocks(graph, node_ordering):

    greens = filter(lambda n: n.attr['fillcolor'] == u"green", graph.nodes())

    probe_map = get_probe_map(graph, greens)

    return blocks_from_map(probe_map, node_ordering, accepting=True)

def rejecting_blocks(graph, node_ordering):

    reds = filter(lambda node: node.attr['fillcolor'] == u"red", graph.nodes())
    rejecting_states = set(reds)

    probe_map = get_probe_map(graph, rejecting_states)
    return blocks_from_map(probe_map, node_ordering, accepting=False)

def neutral_blocks(graph, node_ordering, probe_ordering):

    neutral_edges = filter(lambda e: e[1].attr['fillcolor'] not in [u"green", u"red"],
                           graph.edges())

    probe_map = {}

    for edge in neutral_edges:
        probe = edge.attr['label']

        if probe not in probe_map:
            probe_map[probe] = []

        probe_map[probe].append(edge[0])

    blocks = []

    for probe in probe_map:

        ordered_nodes = map(lambda n: node_ordering[n], probe_map[probe])
        predicate  = create_predicate(ordered_nodes, probe)

        blocks.append(plain_probe(probe) + "\n" + predicate
                      + "\n{\n"
                      + "\tstate = tf[state][" +
                      str(probe_ordering[probe]) + "];\n"
                      + "}\n")

    return blocks

def inconclusive_block():

    return "dtrace:::END\n/ !HAS_VERDICT /\n" + "{\n\ttrace(\"INCONCLUSIVE\");\n}\n"

def comment_ordering(ordering):
    statements = []

    statements.append("/*")

    for key in sorted(ordering.keys()):
        statements.append(" ".join([key, "mapped to", str(ordering[key])]))

    statements.append("*/")

    return "\n".join(statements) + "\n"

def create_dscript(automata, mapping):

        G = enforce_mapping(automata, mapping)

        #The node we actually start in, not the artificial start node
        start_node = find_start_node(G.edges())

        #Having used the artificial start node to find the real start node,
        #we remove the artificial startnode.
        G.remove_node(u'start')

        G = remove_question_edges(G)

        # We want to use a two-dimensional static array of integers
        # to encode the transition function, therefore we need to
        # map each node to a number and every unique dtrace probe
        # to a number.

        # We map the start_node to 0 as this makes initializing the
        # state variable trivial, and the others to consecutive numbers
        # until all nodes are mapped to an integer.
        node_ordering = create_node_ordering(G, start_node)

        # Similarly, we map every probe to an integer.
        probe_ordering = create_probe_ordering(G)

        statements = []

        statements.append(dtrace_preamble())
        statements.append(script_signature())
        statements.append(comment_ordering(node_ordering))
        statements.append(comment_ordering(probe_ordering))

        statements.append(control_variables_declaration())
        statements.append(transition_function_declaration(G))
        statements.append(begin_block(G, node_ordering, probe_ordering))

        for block in accepting_blocks(G, node_ordering):
            statements.append(block)

        for block in rejecting_blocks(G, node_ordering):
            statements.append(block)

        for block in neutral_blocks(G, node_ordering, probe_ordering):
            statements.append(block)

        statements.append(inconclusive_block())

        return "\n".join(statements)

if __name__ == '__main__':

    arguments = docopt(__doc__, version=VERSION)

    automata = load_automata(arguments['FILE'])

    mapping = None

    if arguments['--mapping']:
        mapping = load_mapping(arguments['<map>'])

    print create_dscript(automata, mapping)
